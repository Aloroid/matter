[{"title":"Using CollectionService tags","type":0,"sectionRef":"#","url":"docs/CollectionService","content":"Using CollectionService tags As a pure ECS first and foremost, Matter provides no special functionality for CollectionService tags out of the box. However, it's rather simple to implement this yourself. Here's an example taken from the official Matter example game. local boundTags = { Spinner = Components.Spinner, } local function spawnBound(instance, component) local id = world:spawn( component(), Components.Bind({ instance = instance, }), Components.Transform({ cframe = instance.CFrame, }) ) instance:SetAttribute(&quot;entityId&quot;, id) end for tagName, component in pairs(boundTags) do for _, instance in ipairs(CollectionService:GetTagged(tagName)) do spawnBound(instance, component) end CollectionService:GetInstanceAddedSignal(tagName):Connect(function(instance) spawnBound(instance, component) end) CollectionService:GetInstanceRemovedSignal(tagName):Connect(function(instance) local id = instance:GetAttribute(&quot;entityId&quot;) if id then world:despawn(id) end end) end Copy This example can be modified to meet your game's needs as you see fit.","keywords":""},{"title":"Matter","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Goals​","type":1,"pageTitle":"Matter","url":"docs/intro#goals","content":"Simple, obvious APIPerformantGreat debuggability, error handling and insight into what's actually happening each frameCommon patterns are easy to fall into and hard to mess up "},{"title":"Non-goals​","type":1,"pageTitle":"Matter","url":"docs/intro#non-goals","content":"Many similar libraries, ECS or not, end up with a bloated API, requiring significant cognitive overhead to use. We want to avoid this as much as possible.We don't want to provide every thing the user could ever want in our library. Instead, it should be easy for users to write obvious code that does those things. "},{"title":"Performance today​","type":1,"pageTitle":"Matter","url":"docs/intro#performance-today","content":"Matter currently achieves an average frame time of 0.65ms spent inside Matter code for the following benchmark: World with 1000 entitiesBetween 2-30 components on each entity300 unique component types200 systemsEach system queries between 1 and 10 components "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/GettingStarted","content":"","keywords":""},{"title":"Next steps​","type":1,"pageTitle":"Getting Started","url":"docs/GettingStarted#next-steps","content":"You should dive in to the API reference! The Matter API is simple and documented in detail. A more detailed usage guide will be written eventually, offering an introduction to ECS architecture and going over more of Matter's design philosophy. "},{"title":"Component","type":0,"sectionRef":"#","url":"api/Component","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Component","url":"api/Component#types","content":" "},{"title":"ComponentInstance​","type":1,"pageTitle":"Component","url":"api/Component#ComponentInstance","content":"&lt;/&gt; type ComponentInstance = {} The ComponentInstance type refers to an actual piece of data that can exist on an entity. The metatable of the component instance table is set to its particular Component table. A component instance can be created by calling the Component table: -- Component: local MyComponent = Matter.component(&quot;My component&quot;) -- component instance: local myComponentInstance = MyComponent({ some = &quot;data&quot; }) print(getmetatable(myComponentInstance) == MyComponent) --&gt; true  "},{"title":"Functions​","type":1,"pageTitle":"Component","url":"api/Component#functions","content":" "},{"title":"patch​","type":1,"pageTitle":"Component","url":"api/Component#patch","content":"&lt;/&gt; Component:patch( partialNewData: {}-- The table to be merged with the existing component data. ) → ComponentInstance-- A copy of the component instance with values from partialNewData overriding existing values. for id, target in world:query(Target) do if shouldChangeTarget(target) then world:insert(id, target:patch({ -- modify the existing component currentTarget = getNewTarget() })) end end A utility function used to immutably modify an existing component instance. Key/value pairs from the passed table will override those of the existing component instance. As all components are immutable and frozen, it is not possible to modify the existing component directly. You can use the Matter.None constant to remove a value from the component instance: target:patch({ currentTarget = Matter.None -- sets currentTarget to nil })  "},{"title":"QueryResult","type":0,"sectionRef":"#","url":"api/QueryResult","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"QueryResult","url":"api/QueryResult#functions","content":" "},{"title":"next​","type":1,"pageTitle":"QueryResult","url":"api/QueryResult#next","content":"&lt;/&gt; QueryResult:next() → ( id,-- Entity ID ...ComponentInstance-- The requested component values ) Returns the next set of values from the query result. Once all results have been returned, the QueryResult is exhausted and is no longer useful. info This function is equivalent to calling the QueryResult as a function. When used in a for loop, this is implicitly done by the language itself. -- Using world:query in this position will make Lua invoke the table as a function. This is conventional. for id, enemy, charge, model in world:query(Enemy, Charge, Model) do -- Do something end If you wanted to iterate over the QueryResult without a for loop, it's recommended that you call next directly instead of calling the QueryResult as a function. local id, enemy, charge, model = world:query(Enemy, Charge, Model):next() local id, enemy, charge, model = world:query(Enemy, Charge, Model)() -- Possible, but unconventional   "},{"title":"without​","type":1,"pageTitle":"QueryResult","url":"api/QueryResult#without","content":"&lt;/&gt; QueryResult:without( ...: Component-- The component types to filter against. ) → () → ( id, ...ComponentInstance )-- Iterator of entity ID followed by the requested component values Returns an iterator that will skip any entities that also have the given components. tip This is essentially equivalent to querying normally, using World:get to check if a component is present, and using Lua's continue keyword to skip this iteration (though, using :without is faster). This means that you should avoid queries that return a very large amount of results only to filter them down to a few with :without. If you can, always prefer adding components and making your query more specific. for id in world:query(Target):without(Model) do -- Do something end  "},{"title":"Loop","type":0,"sectionRef":"#","url":"api/Loop","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Loop","url":"api/Loop#types","content":" "},{"title":"System​","type":1,"pageTitle":"Loop","url":"api/Loop#System","content":"&lt;/&gt; type System = SystemTable | (...any) → () Either a plain function or a table defining the system.  "},{"title":"SystemTable​","type":1,"pageTitle":"Loop","url":"api/Loop#SystemTable","content":"&lt;/&gt; interface SystemTable { system: (...any) → ()-- The system function event?: string-- The event the system runs on. A string, a key from the table you pass to Loop:begin. priority?: number-- Priority influences the position in the frame the system is scheduled to run at. after?: {System}-- A list of systems that this system must run after. } A table defining a system with possible options. Systems are scheduled in order of priority, meaning lower priority runs first. The default priority is 0. "},{"title":"Functions​","type":1,"pageTitle":"Loop","url":"api/Loop#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Loop","url":"api/Loop#new","content":"&lt;/&gt; Loop.new( ...: ...any-- Values that will be passed to all of your systems ) → Loop Creates a new loop. Loop.new accepts as arguments the values that will be passed to all of your systems. So typically, you want to pass the World in here, as well as maybe a table of global game state. local world = World.new() local gameState = {} local loop = Loop.new(world, gameState)   "},{"title":"scheduleSystems​","type":1,"pageTitle":"Loop","url":"api/Loop#scheduleSystems","content":"&lt;/&gt; Loop:scheduleSystems( systems: {System}-- Array of systems to schedule. ) → () Schedules a set of systems based on the constraints they define. Systems may optionally declare: The name of the event they run on (e.g., RenderStepped, Stepped, Heartbeat) A numerical priority value Other systems that they must run after If systems do not specify an event, they will run on the default event. Systems that share an event will run in order of their priority, which means that systems with a lower priority value run first. The default priority is 0. Systems that have defined what systems they run after can only be scheduled after all systems they depend on have already been scheduled. All else being equal, the order in which systems run is stable, meaning if you don't change your code, your systems will always run in the same order across machines. info It is possible for your systems to be in an unresolvable state. In which case, scheduleSystems will error. This can happen when your systems have circular or unresolvable dependency chains. If a system has both a priority and defines systems it runs after, the system can only be scheduled if all of the systems it depends on have a lower or equal priority. Systems can never depend on systems that run on other events, because it is not guaranteed or required that events will fire every frame or will always fire in the same order. caution scheduleSystems has to perform nontrivial sorting work each time it's called, so you should avoid calling it multiple times if possible.  "},{"title":"begin​","type":1,"pageTitle":"Loop","url":"api/Loop#begin","content":"&lt;/&gt; Loop:begin( events: {[string]: RBXScriptSignal }-- A map from event name to event objects. ) → {[string]: RBXScriptConnection }-- A map from your event names to connection objects. Connects to frame events and starts invoking your systems. Pass a table of events you want to be able to run systems on, a map of name to event. Systems can use these names to define what event they run on. By default, systems run on an event named &quot;default&quot;. Custom events may be used if they have a Connect function. loop:begin({ default = RunService.Heartbeat, Heartbeat = RunService.Heartbeat, RenderStepped = RunService.RenderStepped, Stepped = RunService.Stepped, }) info Events that do not have any systems scheduled to run on them at the time you call Loop:begin will be skipped and never connected to. All systems should be scheduled before you call this function. Returns a table similar to the one you passed in, but the values are RBXScriptConnection values (or whatever is returned by :Connect if you passed in a synthetic event).  "},{"title":"addMiddleware​","type":1,"pageTitle":"Loop","url":"api/Loop#addMiddleware","content":"&lt;/&gt; Loop:addMiddleware(middleware: (nextFn: () → ()) → () → ()) → () Adds a user-defined middleware function that is called during each frame. This allows you to run code before and after each frame, to perform initialization and cleanup work. loop:addMiddleware(function(nextFn) return function() Plasma.start(plasmaNode, nextFn) end end) You must pass addMiddleware a function that itself returns a function that invokes nextFn at some point. The outer function is invoked only once. The inner function is invoked during each frame event. info Middleware added later &quot;wraps&quot; middleware that was added earlier. The innermost middleware function is the internal function that actually calls your systems. "},{"title":"Matter","type":0,"sectionRef":"#","url":"api/Matter","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Matter","url":"api/Matter#properties","content":" "},{"title":"World​","type":1,"pageTitle":"Matter","url":"api/Matter#World","content":"&lt;/&gt; Matter.World: World   "},{"title":"Loop​","type":1,"pageTitle":"Matter","url":"api/Matter#Loop","content":"&lt;/&gt; Matter.Loop: Loop   "},{"title":"None​","type":1,"pageTitle":"Matter","url":"api/Matter#None","content":"&lt;/&gt; Matter.None: None A value should be interpreted as nil when merging dictionaries. Matter.None is used by Component:patch. "},{"title":"Functions​","type":1,"pageTitle":"Matter","url":"api/Matter#functions","content":" "},{"title":"useDeltaTime​","type":1,"pageTitle":"Matter","url":"api/Matter#useDeltaTime","content":"&lt;/&gt; Matter.useDeltaTime() → number  Topologically-aware function This function is only usable if called within the context of Loop:begin. Returns the os.clock() time delta between the start of this and last frame.  "},{"title":"useEvent​","type":1,"pageTitle":"Matter","url":"api/Matter#useEvent","content":"&lt;/&gt; Matter.useEvent( instance: Instance ,-- The instance that has the event you want to connect to event: string | RBXScriptSignal -- The name of or actual event that you want to connect to ) → () → ( number, ...any )  Topologically-aware function This function is only usable if called within the context of Loop:begin. Collects events that fire during the frame and allows iteration over event arguments. for _, player in ipairs(Players:GetPlayers()) do for i, character in useEvent(player, &quot;CharacterAdded&quot;) do world:spawn( Components.Target(), Components.Model({ model = character, }) ) end end Returns an iterator function that returns an ever-increasing number, starting at 1, followed by any event arguments from the specified event. Events are returned in the order that they were fired. caution useEvent keys storage uniquely identified by the script and line number useEvent was called from, and the first parameter (instance). If the second parameter, event, is not equal to the event passed in for this unique storage last frame, the old event is disconnected from and the new one is connected in its place. Tl;dr: on a given line, you should hard-code a single event to connect to. Do not dynamically change the event with a variable. Dynamically changing the first parameter (instance) is fine. for _, instance in pairs(someTable) do for i, arg1, arg2 in useEvent(instance, &quot;Touched&quot;) do -- This is ok end end for _, instance in pairs(someTable) do local event = getEventSomehow() for i, arg1, arg2 in useEvent(instance, event) do -- PANIC! This is NOT OK end end If useEvent ceases to be called on the same line with the same instance and event, the event connection is disconnected from automatically. You can also pass the actual event object instead of its name as the second parameter: useEvent(instance, instance.Touched) useEvent(instance, instance:GetPropertyChangedSignal(&quot;Name&quot;))   "},{"title":"useThrottle​","type":1,"pageTitle":"Matter","url":"api/Matter#useThrottle","content":"&lt;/&gt; Matter.useThrottle( seconds: number,-- The number of seconds to throttle for discriminator?: any-- A unique value to additionally key by ) → ()  Topologically-aware function This function is only usable if called within the context of Loop:begin. Utility for easy time-based throttling. Accepts a duration, and returns true if it has been that long since the last time this function returned true. Always returns true the first time. This function returns unique results keyed by script and line number. Additionally, uniqueness can be keyed by a unique value, which is passed as a second parameter. This is useful when iterating over a query result, as you can throttle doing something to each entity individually. if useThrottle(1) then -- Keyed by script and line number only print(&quot;only prints every second&quot;) end for id, enemy in world:query(Enemy) do if useThrottle(5, id) then -- Keyed by script, line number, and the entity id print(&quot;Recalculate target...&quot;) end end   "},{"title":"component​","type":1,"pageTitle":"Matter","url":"api/Matter#component","content":"&lt;/&gt; Matter.component( name?: string-- Optional name for debugging purposes ) → Component-- Your new type of component Creates a new type of component. Call the component as a function to create an instance of that component. -- Component: local MyComponent = Matter.component(&quot;My component&quot;) -- component instance: local myComponentInstance = MyComponent({ some = &quot;data&quot; })   "},{"title":"useHookState​","type":1,"pageTitle":"Matter","url":"api/Matter#useHookState","content":"&lt;/&gt; Matter.useHookState( discriminator?: any,-- A unique value to additionally key by cleanupCallback: (storage: {}) → boolean?-- A function to run when the storage for this hook is cleaned up ) → {}  tip Don't use this function directly in your systems. This function is used for implementing your own topologically-aware functions. It should not be used in your systems directly. You should use this function to implement your own utilities, similar to useEvent and useThrottle. useHookState does one thing: it returns a table. An empty, pristine table. Here's the cool thing though: it always returns the same table, based on the script and line where your function (the function calling useHookState) was called. Uniqueness If your function is called multiple times from the same line, perhaps within a loop, the default behavior ofuseHookState is to uniquely identify these by call count, and will return a unique table for each call. However, you can override this behavior: you can choose to key by any other value. This means that in addition to script and line number, the storage will also only return the same table if the unique value (otherwise known as the &quot;discriminator&quot;) is the same. Cleaning up As a second optional parameter, you can pass a function that is automatically invoked when your storage is about to be cleaned up. This happens when your function (and by extension, useHookState) ceases to be called again next frame (keyed by script, line number, and discriminator). Your cleanup callback is passed the storage table that's about to be cleaned up. You can then perform cleanup work, like disconnecting events. Or, you could return true, and abort cleaning up altogether. If you abort cleanup, your storage will stick around another frame (even if your function wasn't called again). This can be used when you know that the user will (or might) eventually call your function again, even if they didn't this frame. (For example, caching a value for a number of seconds). If cleanup is aborted, your cleanup function will continue to be called every frame, until you don't abort cleanup, or the user actually calls your function again. Example: useThrottle This is the entire implementation of the built-in useThrottle function: local function cleanup(storage) return os.clock() &lt; storage.expiry end local function useThrottle(seconds, discriminator) local storage = useHookState(discriminator, cleanup) if storage.time == nil or os.clock() - storage.time &gt;= seconds then storage.time = os.clock() storage.expiry = os.clock() + seconds return true end return false end A lot of talk for something so simple, right? "},{"title":"World","type":0,"sectionRef":"#","url":"api/World","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"World","url":"api/World#functions","content":" "},{"title":"new​","type":1,"pageTitle":"World","url":"api/World#new","content":"&lt;/&gt; World.new() → () Creates a new World.  "},{"title":"spawn​","type":1,"pageTitle":"World","url":"api/World#spawn","content":"&lt;/&gt; World:spawn( ...: ComponentInstance-- The component values to spawn the entity with. ) → number-- The new entity ID. Spawns a new entity in the world with the given components.  "},{"title":"replace​","type":1,"pageTitle":"World","url":"api/World#replace","content":"&lt;/&gt; World:replace( id: number,-- The entity ID ...: ComponentInstance-- The component values to spawn the entity with. ) → () Replaces a given entity by ID with an entirely new set of components. Equivalent to removing all components from an entity, and then adding these ones.  "},{"title":"despawn​","type":1,"pageTitle":"World","url":"api/World#despawn","content":"&lt;/&gt; World:despawn( id: number-- The entity ID ) → () Despawns a given entity by ID, removing it and all its components from the world entirely.  "},{"title":"clear​","type":1,"pageTitle":"World","url":"api/World#clear","content":"&lt;/&gt; World:clear() → () Removes all entities from the world. warning Removing entities in this way is not reported by queryChanged.  "},{"title":"contains​","type":1,"pageTitle":"World","url":"api/World#contains","content":"&lt;/&gt; World:contains( id: number-- The entity ID ) → bool-- true if the entity exists Checks if the given entity ID is currently spawned in this world.  "},{"title":"get​","type":1,"pageTitle":"World","url":"api/World#get","content":"&lt;/&gt; World:get( id: number,-- The entity ID ...: Component-- The components to fetch ) → ...-- Returns the component values in the same order they were passed in Gets a specific component (or set of components) from a specific entity in this world.  "},{"title":"query​","type":1,"pageTitle":"World","url":"api/World#query","content":"&lt;/&gt; World:query( ...: Component-- The component types to query. Only entities with all of these components will be returned. ) → QueryResult-- See QueryResult docs. Performs a query against the entities in this World. Returns a QueryResult, which iterates over the results of the query. for id, enemy, charge, model in world:query(Enemy, Charge, Model) do -- Do something end for id in world:query(Target):without(Model) do -- Again, with feeling end Modifying the World while iterating Do not insert new components or spawn entities that would then match the query while iterating. The iteration behavior is undefined if the World is changed while iterating so that additional results would be returned. Removing components during iteration may cause the iterator to return the same entity multiple times, if the component would still meet the requirements of the query. It is safe to remove components during iteration if and only if the entity would no longer meet the query requirements. To mitigate against these limitations, simply build up a queue of actions to take after iteration, and then do them after your iteration loop. Inserting existing components and despawning entities during iteration is safe, however.  "},{"title":"queryChanged​","type":1,"pageTitle":"World","url":"api/World#queryChanged","content":"&lt;/&gt; World:queryChanged( componentToTrack: Component,-- The component you want to listen to changes for. ...?: Component-- Additional query components. Checked at time of iteration, not time of change. ) → () → ( id, ChangeRecord, ...ComponentInstance )-- Iterator of entity ID followed by the requested component values, in order "},{"title":"Types","type":1,"pageTitle":"World","url":"api/World##","content":""},{"title":"​","type":1,"pageTitle":"World","url":"api/World#ChangeRecord","content":"interface ChangeRecord { new?: ComponentInstance-- The new value of the component. Nil if just removed. old?: ComponentInstance-- The former value of the component. Nil if just added. }   Topologically-aware function This function is only usable if called within the context of Loop:begin. Queries for components that have changed since the last time your system ran queryChanged. Only one changed record is returned per entity, even if the same entity changed multiple times. The order in which changed records are returned is not guaranteed to be the order that the changes occurred in. It should be noted that queryChanged does not have the same iterator invalidation limitations as World:query. caution The first time your system runs (i.e., on the first frame), no results are returned. Results only begin to be tracked after the first time your system calls this function. info Calling this function from your system creates storage internally for your system. Then, changes meeting your criteria are pushed into your storage. Calling queryChanged again each frame drains this storage. If you do not call queryChanged each frame, or your system isn't called every frame, the storage will continually fill up and does not empty unless you drain it. It is assumed that you will call queryChanged unconditionally, every frame, until the end of time. Arguments The first argument to queryChanged is the component for which you want to track changes. Further arguments are optional, and if passed, are an additional filter on what entities will be returned. caution Additional query arguments are checked against at the time of iteration, not when the change ocurred. This has the additional implication that entities that have been despawned will never be returned from queryChanged if additional query arguments are passed, because the entity will have no components, so cannot possibly pass any additional query. If no additional query arguments are passed, all changes (including despawns) will be tracked and returned. Returns queryChanged returns an iterator function, so you call it in a for loop just like World:query. The iterator returns the entity ID, followed by a ChangeRecord, followed by the component instance values of any additional query arguments that were passed (as discussed above). The ChangeRecord type is a table that contains two fields, new and old, respectively containing the new component instance, and the old component instance. new and old will never be the same value. new will be nil if the component was removed (or the entity was despawned), and old will be nil if the component was just added. The ChangeRecord table is given to all systems tracking changes for this component, and cannot be modified. for id, modelRecord, enemy in world:queryChanged(Model, Enemy) do if modelRecord.new == nil then -- Model was removed if enemy.type == &quot;this is a made up example&quot; then world:remove(id, Enemy) end end end info It's conventional to end the name you assign the record with &quot;-Record&quot;, to make clear it is a different shape than a regular component instance. The ChangeValue is a table with new and old fields, but additional returns for the additional query arguments are regular component instances.  "},{"title":"insert​","type":1,"pageTitle":"World","url":"api/World#insert","content":"&lt;/&gt; World:insert( id: number,-- The entity ID ...: ComponentInstance-- The component values to insert ) → () Inserts a component (or set of components) into an existing entity. If another instance of a given component already exists on this entity, it is replaced. world:insert( entityId, ComponentA({ foo = &quot;bar&quot; }), ComponentB({ baz = &quot;qux&quot; }) )   "},{"title":"remove​","type":1,"pageTitle":"World","url":"api/World#remove","content":"&lt;/&gt; World:remove( id: number,-- The entity ID ...: Component-- The components to remove ) → ...ComponentInstance-- Returns the component instance values that were removed in the order they were passed. Removes a component (or set of components) from an existing entity. local removedA, removedB = world:remove(entityId, ComponentA, ComponentB)   "},{"title":"size​","type":1,"pageTitle":"World","url":"api/World#size","content":"&lt;/&gt; World:size() → () Returns the number of entities currently spawned in the world. "}]